"""Entry points for the Krutilka VNB Telegram bot."""
from __future__ import annotations

import logging
from typing import Any, Awaitable, Callable, Dict, Final, List, Optional, Tuple
from uuid import uuid4

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, User
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

from repositories.client_repository import create_client, get_client, search_clients
from repositories.client_link_repository import (
    get_link_by_client,
    get_link_by_user,
    link_user_to_client,
)
from repositories.admin_repository import get_admin_ids, is_admin

LOGGER = logging.getLogger(__name__)

_GREETING_KEY: Final[str] = "krutilkavnbot:greeting"
_CANDIDATES_KEY: Final[str] = "krutilkavnbot:candidates"
_FORM_KEY: Final[str] = "krutilkavnbot:form"
_PENDING_APPROVALS_KEY: Final[str] = "krutilkavnbot:pending_approvals"
_LAST_SEARCH_KEY: Final[str] = "krutilkavnbot:last_name"

DEFAULT_GREETING: Final[str] = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!"
MAX_SUGGESTIONS: Final[int] = 6

(
    ASK_LAST_NAME,
    CONFIRM_LINK,
    FORM_FIRST_NAME,
    FORM_LAST_NAME,
    FORM_WEIGHT,
    FORM_HEIGHT,
    FORM_GENDER,
    FORM_FTP,
    FORM_PEDALS,
    FORM_GOAL,
) = range(10)

_PEDAL_CHOICES: Final[List[Tuple[str, str]]] = [
    ("—Ç–æ–ø—Ç–∞–ª–∫–∏ (–ø–æ–¥ –∫—Ä–æ—Å—Å–æ–≤–∫–∏)", "platform"),
    ("–∫–æ–Ω—Ç–∞–∫—Ç—ã —à–æ—Å—Å–µ Look", "road_look"),
    ("–∫–æ–Ω—Ç–∞–∫—Ç—ã —à–æ—Å—Å–µ Shimano", "road_shimano"),
    ("–∫–æ–Ω—Ç–∞–∫—Ç—ã MTB Shimano", "mtb_shimano"),
    ("–ø—Ä–∏–Ω–µ—Å—É —Å–≤–æ–∏", "own"),
]

_PEDAL_LABEL_BY_CODE: Final[Dict[str, str]] = {code: label for label, code in _PEDAL_CHOICES}
_GENDER_LABELS: Final[Dict[str, str]] = {"male": "–ú", "female": "–ñ"}


def _normalize_last_name(value: str) -> str:
    return value.strip().lower()


def _format_client_label(client: Dict[str, Any]) -> str:
    last_name = (client.get("last_name") or "").strip()
    first_name = (client.get("first_name") or "").strip()
    full_name = (client.get("full_name") or "").strip()

    if last_name and first_name:
        display = f"{last_name} {first_name}".strip()
    elif full_name:
        display = full_name
    else:
        display = last_name or first_name or "–ë–µ–∑ –∏–º–µ–Ω–∏"
    return f"{display} (ID {client.get('id')})"


def _find_clients_by_last_name(last_name: str) -> List[Dict[str, Any]]:
    normalized = _normalize_last_name(last_name)
    results = search_clients(last_name, limit=MAX_SUGGESTIONS * 2)
    exact_matches = [
        client for client in results if _normalize_last_name(client.get("last_name") or "") == normalized
    ]
    if exact_matches:
        return exact_matches[:MAX_SUGGESTIONS]
    return results[:MAX_SUGGESTIONS]


def _store_candidates(context: ContextTypes.DEFAULT_TYPE, clients: List[Dict[str, Any]]) -> None:
    context.user_data[_CANDIDATES_KEY] = {str(client["id"]): client for client in clients}


def _get_candidates(context: ContextTypes.DEFAULT_TYPE) -> Dict[str, Dict[str, Any]]:
    return context.user_data.get(_CANDIDATES_KEY, {})


def _clear_candidates(context: ContextTypes.DEFAULT_TYPE) -> None:
    context.user_data.pop(_CANDIDATES_KEY, None)


def _get_form(context: ContextTypes.DEFAULT_TYPE) -> Dict[str, Any]:
    form = context.user_data.get(_FORM_KEY)
    if form is None:
        form = {}
        context.user_data[_FORM_KEY] = form
    return form


def _start_new_client_form(context: ContextTypes.DEFAULT_TYPE, last_name: str) -> Dict[str, Any]:
    form = {
        "last_name": last_name.strip(),
        "ftp": 150.0,
    }
    context.user_data[_FORM_KEY] = form
    return form


def _clear_form(context: ContextTypes.DEFAULT_TYPE) -> None:
    context.user_data.pop(_FORM_KEY, None)


def _pending_approvals(context: ContextTypes.DEFAULT_TYPE) -> Dict[str, Dict[str, Any]]:
    approvals = context.application.bot_data.setdefault(_PENDING_APPROVALS_KEY, {})
    return approvals


def _store_pending_request(context: ContextTypes.DEFAULT_TYPE, request: Dict[str, Any]) -> None:
    approvals = _pending_approvals(context)
    approvals[request["request_id"]] = request


def _get_pending_request(context: ContextTypes.DEFAULT_TYPE, request_id: str) -> Optional[Dict[str, Any]]:
    approvals = _pending_approvals(context)
    return approvals.get(request_id)


def _pop_pending_request(context: ContextTypes.DEFAULT_TYPE, request_id: str) -> Optional[Dict[str, Any]]:
    approvals = _pending_approvals(context)
    return approvals.pop(request_id, None)


def _format_user_label(user: Optional[User]) -> str:
    if user is None:
        return "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"

    first = (user.first_name or "").strip()
    last = (user.last_name or "").strip()
    parts = [part for part in [first, last] if part]
    display = " ".join(parts) if parts else (user.username or f"id {user.id}")
    if user.username:
        handle = user.username if user.username.startswith("@") else f"@{user.username}"
        display = f"{display} ({handle})"
    return display


def _is_admin_user(user: Optional[User]) -> bool:
    tg_id = user.id if user else None
    username = user.username if user else None
    try:
        return is_admin(tg_id=tg_id, username=username)
    except Exception:
        LOGGER.exception("Failed to check admin status for user %s", tg_id)
        return False


def _parse_optional_float(text: str) -> Tuple[bool, Optional[float]]:
    value = text.replace(",", ".").strip()
    if not value or value == "-":
        return True, None
    try:
        return True, float(value)
    except ValueError:
        return False, None


def _parse_positive_float(text: str) -> Tuple[bool, Optional[float]]:
    ok, value = _parse_optional_float(text)
    if not ok or value is None:
        return False, None
    if value <= 0:
        return False, None
    return True, value


def _format_optional_number(value: Optional[float]) -> str:
    if value is None:
        return "‚Äî"
    return f"{value:g}"


def _format_gender_label(gender: Optional[str]) -> str:
    if gender is None:
        return "‚Äî"
    return _GENDER_LABELS.get(gender, gender)


def _skip_keyboard(callback: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("–û–ö", callback_data=callback)]])


async def _send_gender_prompt(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
    keyboard = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("–ú", callback_data="form:set:gender:male"),
                InlineKeyboardButton("–ñ", callback_data="form:set:gender:female"),
            ]
        ]
    )
    await context.bot.send_message(chat_id, "üë§ –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à –ø–æ–ª:", reply_markup=keyboard)


async def _send_pedals_prompt(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
    rows = [
        [InlineKeyboardButton(label, callback_data=f"form:set:pedals:{code}")]
        for label, code in _PEDAL_CHOICES
    ]
    await context.bot.send_message(chat_id, "üö¥ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–µ–¥–∞–ª–µ–π:", reply_markup=InlineKeyboardMarkup(rows))


async def _send_ftp_prompt(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
    await context.bot.send_message(
        chat_id,
        "‚ö° –í–≤–µ–¥–∏—Ç–µ –≤–∞—à FTP (–≤–∞—Ç—Ç—ã). –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 150. –ß—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –Ω–∞–∂–º–∏—Ç–µ ¬´–û–ö¬ª.",
        reply_markup=_skip_keyboard("form:skip:ftp"),
    )


async def _send_goal_prompt(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
    await context.bot.send_message(
        chat_id,
        "üéØ –û–ø–∏—à–∏—Ç–µ –≤–∞—à—É —Ü–µ–ª—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Å—Ç–∞—Ä—Ç—É).\n"
        "–ï—Å–ª–∏ –Ω–µ —Ö–æ—Ç–∏—Ç–µ —É–∫–∞–∑—ã–≤–∞—Ç—å, –Ω–∞–∂–º–∏—Ç–µ ¬´–û–ö¬ª.",
        reply_markup=_skip_keyboard("form:skip:goal"),
    )


async def _request_admin_approval(
    *,
    context: ContextTypes.DEFAULT_TYPE,
    user: User,
    client: Dict[str, Any],
    existing: Optional[Dict[str, Any]],
    respond_initial: Callable[[str], Awaitable[Any]],
    user_chat_id: int,
    on_failure: Optional[Callable[[str], Awaitable[Any]]] = None,
) -> bool:
    try:
        admin_ids = [admin_id for admin_id in get_admin_ids() if admin_id]
    except Exception:
        LOGGER.exception("Failed to load admin IDs for approval request")
        admin_ids = []

    if not admin_ids:
        message = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã."
        await respond_initial(message)
        if on_failure:
            await on_failure("–ó–∞–ø—Ä–æ—Å –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É, —á—Ç–æ–±—ã –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–æ—Å—Ç—É–ø.")
        else:
            await context.bot.send_message(
                user_chat_id,
                "–ó–∞–ø—Ä–æ—Å –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É, —á—Ç–æ–±—ã –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –¥–æ—Å—Ç—É–ø.",
            )
        return False

    request_id = uuid4().hex
    tg_username = user.username if user.username else None
    tg_full_name = " ".join(filter(None, [user.first_name, user.last_name])).strip() or None

    request: Dict[str, Any] = {
        "request_id": request_id,
        "client": client,
        "user_id": user.id,
        "user_username": tg_username,
        "user_full_name": tg_full_name,
        "user_chat_id": user_chat_id,
        "existing": existing,
        "admin_messages": [],
    }
    _store_pending_request(context, request)

    await respond_initial(
        f"–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–∏–≤—è–∑–∫—É –∫–ª–∏–µ–Ω—Ç–∞ {_format_client_label(client)} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É. "
        "–û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.",
    )

    await _notify_admins(context, request, admin_ids)
    if not request["admin_messages"]:
        _pop_pending_request(context, request_id)
        failure_text = (
            "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π."
        )
        await respond_initial(failure_text)
        if on_failure:
            await on_failure("–ó–∞–ø—Ä–æ—Å –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω. –°–æ–æ–±—â–∏—Ç–µ –æ–± —ç—Ç–æ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –∏–ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–∑–∂–µ.")
        else:
            await context.bot.send_message(
                user_chat_id,
                "–ó–∞–ø—Ä–æ—Å –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω. –°–æ–æ–±—â–∏—Ç–µ –æ–± —ç—Ç–æ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –∏–ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–∑–∂–µ.",
            )
        return False

    return True


async def _start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    user = update.effective_user
    if message is None or user is None:
        LOGGER.debug("Cannot handle /start without message or user in update %s", update.update_id)
        return ConversationHandler.END

    _clear_candidates(context)
    _clear_form(context)
    greeting: str = context.application.bot_data.get(_GREETING_KEY, DEFAULT_GREETING)

    linked_client_name: Optional[str] = None
    try:
        existing = get_link_by_user(user.id)
        if existing:
            client = get_client(existing["client_id"])
            if client:
                linked_client_name = _format_client_label(client)
    except Exception:
        LOGGER.exception("Failed to check existing link for user %s", user.id)

    intro = (
        "üëã –≠—Ç–æ –±–æ—Ç –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ –ø–µ—Ä–≤—É—é –≤–µ–ª–æ—Å—Ç—É–¥–∏—é –≤ –í–µ–ª–∏–∫–æ–º –ù–æ–≤–≥–æ—Ä–æ–¥–µ ¬´–ö—Ä—É—Ç–∏–ª–∫—É¬ª.\n"
        "–ï—Å–ª–∏ –≤—ã —É–∂–µ –±—ã–ª–∏ —É –Ω–∞—Å, –º—ã –Ω–∞–π–¥—ë–º –≤–∞—à—É –∞–Ω–∫–µ—Ç—É –∏ –ø—Ä–∏–≤—è–∂–µ–º –µ—ë –∫ Telegram.\n"
        "–ï—Å–ª–∏ –≤—ã –Ω–æ–≤—ã–π —É—á–∞—Å—Ç–Ω–∏–∫, —Å–æ–∑–¥–∞–¥–∏–º –∞–Ω–∫–µ—Ç—É –ø—Ä—è–º–æ –∑–¥–µ—Å—å."
    )

    if linked_client_name:
        text = (
            f"{greeting}\n\n{intro}\n\n"
            f"‚úÖ –£–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ {linked_client_name}.\n"
            "–ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —Å–≤—è–∑—å, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é —Ñ–∞–º–∏–ª–∏—é —Å–Ω–æ–≤–∞."
        )
    else:
        text = (
            f"{greeting}\n\n{intro}\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é —Ñ–∞–º–∏–ª–∏—é, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å."
        )

    await message.reply_text(text)
    return ASK_LAST_NAME


async def _help_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.effective_message
    if message is None:
        return
    await message.reply_text(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ /start, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é. "
        "–ë–æ—Ç –ø–æ–ø—Ä–æ—Å–∏—Ç –≤–∞—à—É —Ñ–∞–º–∏–ª–∏—é –∏ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç –≤—ã–±—Ä–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞ –∏–∑ —Å–ø–∏—Å–∫–∞. "
        "–ï—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ—Ç –≤ –±–∞–∑–µ, –º–æ–∂–Ω–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–æ—Ä–æ—Ç–∫—É—é –∞–Ω–∫–µ—Ç—É –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏.",
    )


async def _unknown_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.effective_message
    if message is None:
        return
    await message.reply_text("–ö–æ–º–∞–Ω–¥–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.")


async def _handle_last_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return ASK_LAST_NAME

    _clear_candidates(context)
    _clear_form(context)

    last_name = message.text.strip()
    if not last_name:
        await message.reply_text("‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–º–∏–ª–∏—é —Ç–µ–∫—Å—Ç–æ–º.")
        return ASK_LAST_NAME

    context.user_data[_LAST_SEARCH_KEY] = last_name

    try:
        clients = _find_clients_by_last_name(last_name)
    except Exception:
        LOGGER.exception("Failed to search clients by last name %r", last_name)
        await message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–æ–∏—Å–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ.")
        return ASK_LAST_NAME

    if not clients:
        _start_new_client_form(context, last_name)
        await message.reply_text(
            "üîé –ö–ª–∏–µ–Ω—Ç–æ–≤ —Å —Ç–∞–∫–æ–π —Ñ–∞–º–∏–ª–∏–µ–π –Ω–µ –Ω–∞—à–ª–æ—Å—å. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å.\n"
            "üñäÔ∏è –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—ë –∏–º—è:"
        )
        _clear_candidates(context)
        return FORM_FIRST_NAME

    _store_candidates(context, clients)

    rows: List[List[InlineKeyboardButton]] = [
        [
            InlineKeyboardButton(
                text=_format_client_label(client),
                callback_data=f"link:{client['id']}",
            )
        ]
        for client in clients
    ]
    rows.append([InlineKeyboardButton("–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å", callback_data="new_client")])
    keyboard = InlineKeyboardMarkup(rows)
    lines = ["üìã –ù–∞—à–ª–∏—Å—å —Ç–∞–∫–∏–µ –∫–ª–∏–µ–Ω—Ç—ã:"]
    for client in clients:
        lines.append(f"‚Ä¢ {_format_client_label(client)}")
    if len(clients) >= MAX_SUGGESTIONS:
        lines.append("–ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –Ω—É–∂–Ω–æ–≥–æ, —É—Ç–æ—á–Ω–∏—Ç–µ —Ñ–∞–º–∏–ª–∏—é –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–Ω–æ–≤–∞.")
    lines.append("‚ÑπÔ∏è –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å¬ª, —á—Ç–æ–±—ã –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É.")

    await message.reply_text("\n".join(lines), reply_markup=keyboard)
    return CONFIRM_LINK


async def _handle_link_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = update.effective_user
    if query is None or user is None:
        LOGGER.debug("Callback without query or user in update %s", update.update_id)
        return ASK_LAST_NAME

    await query.answer()
    data = query.data or ""
    if not data.startswith("link:"):
        await query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.", show_alert=True)
        return ASK_LAST_NAME

    client_id = data.split(":", 1)[1]
    candidates = _get_candidates(context)
    client = candidates.get(client_id)
    if client is None:
        await query.answer("–°–ø–∏—Å–æ–∫ —É—Å—Ç–∞—Ä–µ–ª. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–º–∏–ª–∏—é –µ—â—ë —Ä–∞–∑.", show_alert=True)
        return ASK_LAST_NAME

    try:
        existing = get_link_by_client(client["id"])
    except Exception:
        existing = None

    success = await _request_admin_approval(
        context=context,
        user=user,
        client=client,
        existing=existing,
        respond_initial=query.edit_message_text,
        user_chat_id=query.message.chat_id if query.message else user.id,
        on_failure=query.message.reply_text if query.message else None,
    )

    if success and query.message:
        await query.message.reply_text(
            "–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º. –ü–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø—Ä–∏–≤—è–∑–∫–∏ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ. "
            "–ß—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é —Ñ–∞–º–∏–ª–∏—é.",
        )

    return ASK_LAST_NAME


async def _handle_new_client_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query is None or query.message is None:
        return FORM_FIRST_NAME

    await query.answer()
    last_name = context.user_data.get(_LAST_SEARCH_KEY, "")

    _clear_candidates(context)
    _start_new_client_form(context, last_name)

    try:
        await query.edit_message_text("üÜï –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏.")
    except Exception:
        LOGGER.debug("Failed to edit new-client message", exc_info=True)

    prompt_lines = []
    if last_name:
        prompt_lines.append(f"‚úÖ –§–∞–º–∏–ª–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {last_name}")
    prompt_lines.append("üñäÔ∏è –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—ë –∏–º—è:")
    await query.message.reply_text("\n".join(prompt_lines))
    return FORM_FIRST_NAME


async def _handle_form_first_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return FORM_FIRST_NAME

    first_name = message.text.strip()
    if not first_name:
        await message.reply_text("‚ö†Ô∏è –ò–º—è –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ—ë –∏–º—è.")
        return FORM_FIRST_NAME

    form = _get_form(context)
    form["first_name"] = first_name
    current_last_name = form.get("last_name") or ""
    if current_last_name:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("–û—Å—Ç–∞–≤–∏—Ç—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π", callback_data="form:keep:last_name")]]
        )
        await message.reply_text(
            f"üßæ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–≤–æ—é —Ñ–∞–º–∏–ª–∏—é (—Å–µ–π—á–∞—Å: {current_last_name}) –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é.",
            reply_markup=keyboard,
        )
    else:
        await message.reply_text("üñäÔ∏è –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é —Ñ–∞–º–∏–ª–∏—é:")
    return FORM_LAST_NAME


async def _handle_form_last_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return FORM_LAST_NAME

    value = message.text.strip()
    if not value:
        await message.reply_text("‚ö†Ô∏è –§–∞–º–∏–ª–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π. –í–≤–µ–¥–∏—Ç–µ —Å–≤–æ—é —Ñ–∞–º–∏–ª–∏—é.")
        return FORM_LAST_NAME

    form = _get_form(context)
    form["last_name"] = value
    await message.reply_text(
        "‚öñÔ∏è –í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–µ—Å –≤ –∫–∏–ª–æ–≥—Ä–∞–º–º–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 72.5). –≠—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ."
    )
    return FORM_WEIGHT


async def _keep_last_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query is None or query.message is None:
        return FORM_LAST_NAME

    await query.answer()
    form = _get_form(context)
    last_name = (form.get("last_name") or "").strip()
    if not last_name:
        await query.answer("–§–∞–º–∏–ª–∏—è –µ—â—ë –Ω–µ —É–∫–∞–∑–∞–Ω–∞.", show_alert=True)
        return FORM_LAST_NAME

    try:
        await query.edit_message_text(f"‚úÖ –§–∞–º–∏–ª–∏—è: {last_name}")
    except Exception:
        LOGGER.debug("Failed to edit keep-last-name message", exc_info=True)

    await query.message.reply_text(
        "‚öñÔ∏è –í–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–µ—Å –≤ –∫–∏–ª–æ–≥—Ä–∞–º–º–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 72.5). –≠—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ."
    )
    return FORM_WEIGHT


async def _handle_form_weight(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return FORM_WEIGHT

    ok, weight = _parse_positive_float(message.text)
    if not ok or weight is None:
        await message.reply_text(
            "‚ö†Ô∏è –í–µ—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, 72.5). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑."
        )
        return FORM_WEIGHT

    form = _get_form(context)
    form["weight"] = weight
    await message.reply_text(
        "üìè –í–≤–µ–¥–∏—Ç–µ –≤–∞—à —Ä–æ—Å—Ç –≤ —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 178). –≠—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ."
    )
    return FORM_HEIGHT


async def _handle_form_height(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return FORM_HEIGHT

    ok, height = _parse_positive_float(message.text)
    if not ok or height is None:
        await message.reply_text(
            "‚ö†Ô∏è –†–æ—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, 178). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑."
        )
        return FORM_HEIGHT

    form = _get_form(context)
    form["height"] = height
    await _send_gender_prompt(context, message.chat_id)
    return FORM_GENDER


async def _handle_gender_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query is None or query.message is None:
        return FORM_GENDER

    await query.answer()
    data = query.data or ""
    parts = data.split(":")
    if len(parts) != 4:
        await query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return FORM_GENDER
    gender_code = parts[3]
    if gender_code not in {"male", "female"}:
        await query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return FORM_GENDER

    form = _get_form(context)
    form["gender"] = gender_code

    label = "–ú" if gender_code == "male" else "–ñ"
    try:
        await query.edit_message_text(f"üë§ –ü–æ–ª: {label}")
    except Exception:
        LOGGER.debug("Failed to edit gender selection message", exc_info=True)

    await _send_ftp_prompt(context, query.message.chat_id)
    return FORM_FTP


async def _prompt_gender_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message:
        await message.reply_text("üë§ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ ¬´–ú¬ª –∏–ª–∏ ¬´–ñ¬ª.")
    return FORM_GENDER


async def _handle_form_ftp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message is None or not message.text:
        return FORM_FTP

    ok, ftp = _parse_optional_float(message.text)
    if not ok or (ftp is not None and ftp <= 0):
        await message.reply_text(
            "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å FTP. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 215) –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–û–ö¬ª, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (150)."
        )
        return FORM_FTP

    form = _get_form(context)
    form["ftp"] = 150.0 if ftp is None else ftp
    await _send_pedals_prompt(context, message.chat_id)
    return FORM_PEDALS


async def _skip_ftp(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query is None or query.message is None:
        return FORM_FTP

    await query.answer()
    form = _get_form(context)
    form["ftp"] = form.get("ftp") or 150.0
    try:
        await query.edit_message_text("‚ÑπÔ∏è FTP –æ—Å—Ç–∞–≤–ª–µ–Ω –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (150).")
    except Exception:
        LOGGER.debug("Failed to edit FTP skip message", exc_info=True)
    await _send_pedals_prompt(context, query.message.chat_id)
    return FORM_PEDALS


async def _handle_form_pedals(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    if message:
        await message.reply_text("üö¥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–µ–¥–∞–ª–µ–π —Å –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ.")
    return FORM_PEDALS


async def _handle_pedals_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query is None or query.message is None:
        return FORM_PEDALS

    form = _get_form(context)
    await query.answer()
    data = query.data or ""
    parts = data.split(":")
    if len(parts) != 4:
        await query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return FORM_PEDALS
    code = parts[3]
    label = _PEDAL_LABEL_BY_CODE.get(code)
    if label is None:
        await query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return FORM_PEDALS

    form["pedals"] = label
    try:
        await query.edit_message_text(f"üö¥ –¢–∏–ø –ø–µ–¥–∞–ª–µ–π: {label}")
    except Exception:
        LOGGER.debug("Failed to edit pedals selection message", exc_info=True)
    await _send_goal_prompt(context, query.message.chat_id)
    return FORM_GOAL


async def _handle_form_goal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.effective_message
    user = update.effective_user
    if message is None or user is None or message.text is None:
        return FORM_GOAL

    value = message.text.strip()
    form = _get_form(context)
    form["goal"] = value or None

    return await _finalize_client_creation(
        context=context,
        user=user,
        chat_id=message.chat_id,
        send_message=message.reply_text,
    )


async def _skip_goal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = update.effective_user
    if query is None or query.message is None or user is None:
        return FORM_GOAL

    await query.answer()
    form = _get_form(context)
    form["goal"] = None
    try:
        await query.edit_message_text("‚ÑπÔ∏è –¶–µ–ª—å –Ω–µ —É–∫–∞–∑–∞–Ω–∞.")
    except Exception:
        LOGGER.debug("Failed to edit goal skip message", exc_info=True)

    return await _finalize_client_creation(
        context=context,
        user=user,
        chat_id=query.message.chat_id,
        send_message=lambda text: context.bot.send_message(query.message.chat_id, text),
    )


async def _finalize_client_creation(
    *,
    context: ContextTypes.DEFAULT_TYPE,
    user: User,
    chat_id: int,
    send_message: Callable[[str], Awaitable[Any]],
) -> int:
    form = _get_form(context)

    first_name = (form.get("first_name") or "").strip()
    last_name = (form.get("last_name") or "").strip()
    weight = form.get("weight")
    height = form.get("height")
    gender = form.get("gender")
    ftp = form.get("ftp", 150.0)
    pedals = form.get("pedals")
    goal = form.get("goal")

    if (
        not first_name
        or not last_name
        or weight is None
        or height is None
        or pedals is None
        or gender not in {"male", "female"}
    ):
        await send_message("‚ö†Ô∏è –ê–Ω–∫–µ—Ç–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ –∫–æ–º–∞–Ω–¥–æ–π /start.")
        _clear_form(context)
        return ASK_LAST_NAME

    try:
        client = create_client(
            first_name=first_name,
            last_name=last_name,
            weight=weight,
            height=height,
            gender=gender,
            ftp=ftp,
            pedals=pedals,
            goal=goal,
        )
    except Exception:
        LOGGER.exception("Failed to create client record for %s %s", first_name, last_name)
        await send_message(
            "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )
        _clear_form(context)
        return ASK_LAST_NAME

    summary_lines = [
        "üìù –ê–Ω–∫–µ—Ç–∞ (–ø—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ):",
        f"‚Ä¢ –ò–º—è: {first_name}",
        f"‚Ä¢ –§–∞–º–∏–ª–∏—è: {last_name}",
        f"‚Ä¢ –ü–æ–ª: {_format_gender_label(gender)}",
        f"‚Ä¢ –í–µ—Å: {_format_optional_number(weight)} –∫–≥",
        f"‚Ä¢ –†–æ—Å—Ç: {_format_optional_number(height)} —Å–º",
        f"‚Ä¢ FTP: {_format_optional_number(ftp)} –í—Ç",
        f"‚Ä¢ –ü–µ–¥–∞–ª–∏: {pedals}",
        f"‚Ä¢ –¶–µ–ª—å: {goal or '‚Äî'}",
    ]
    await send_message("\n".join(summary_lines))

    tg_username = user.username if user.username else None
    tg_full_name = " ".join(filter(None, [user.first_name, user.last_name])).strip() or None

    try:
        link_user_to_client(
            tg_user_id=user.id,
            client_id=client["id"],
            tg_username=tg_username,
            tg_full_name=tg_full_name,
        )
        await send_message(f"‚ú® –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å: {_format_client_label(client)}.")
        await send_message(
            "üîó –í–∞—à Telegram –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –Ω–æ–≤–æ–π –∞–Ω–∫–µ—Ç–µ. –ì–æ—Ç–æ–≤–æ!"
        )
    except Exception:
        LOGGER.exception("Failed to link new client %s to user %s", client["id"], user.id)
        await send_message(
            "‚ö†Ô∏è –ó–∞–ø–∏—Å—å —Å–æ–∑–¥–∞–Ω–∞, –Ω–æ –ø—Ä–∏–≤—è–∑–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )

    _clear_form(context)

    return ASK_LAST_NAME


async def _cancel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    _clear_candidates(context)
    _clear_form(context)
    message = update.effective_message
    if message is not None:
        await message.reply_text("–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–µ—Ä–≤–∞–Ω–∞. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start.")
    return ConversationHandler.END


async def _notify_admins(
    context: ContextTypes.DEFAULT_TYPE,
    request: Dict[str, Any],
    admin_ids: List[int],
) -> None:
    client = request["client"]
    user_id = request["user_id"]
    user_username = request.get("user_username")
    user_full_name = request.get("user_full_name")
    existing = request.get("existing")

    client_label = _format_client_label(client)
    user_label_parts: List[str] = []
    if user_full_name:
        user_label_parts.append(user_full_name)
    if user_username:
        handle = user_username if user_username.startswith("@") else f"@{user_username}"
        user_label_parts.append(handle)
    user_label_parts.append(f"id {user_id}")
    user_label = ", ".join(user_label_parts)

    lines = [
        "–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–∏–≤—è–∑–∫—É –∫–ª–∏–µ–Ω—Ç–∞.",
        f"–ö–ª–∏–µ–Ω—Ç: {client_label}",
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_label}",
    ]

    if existing and existing.get("tg_user_id"):
        existing_user_id = existing.get("tg_user_id")
        existing_username = existing.get("tg_username")
        existing_full_name = existing.get("tg_full_name")
        existing_parts = []
        if existing_full_name:
            existing_parts.append(existing_full_name)
        if existing_username:
            handle = existing_username if existing_username.startswith("@") else f"@{existing_username}"
            existing_parts.append(handle)
        if existing_user_id:
            existing_parts.append(f"id {existing_user_id}")
        lines.append("–ü—Ä–µ–¥—ã–¥—É—â–∞—è —Å–≤—è–∑—å: " + ", ".join(existing_parts))

    keyboard = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data=f"approve:{request['request_id']}"),
                InlineKeyboardButton("–û—Ç–º–µ–Ω–∏—Ç—å", callback_data=f"reject:{request['request_id']}"),
            ]
        ]
    )

    for admin_id in admin_ids:
        try:
            message = await context.bot.send_message(
                admin_id,
                "\n".join(lines),
                reply_markup=keyboard,
            )
            request["admin_messages"].append(
                {"chat_id": message.chat_id, "message_id": message.message_id}
            )
        except Exception:
            LOGGER.exception("Failed to send approval request %s to admin %s", request["request_id"], admin_id)


async def _handle_admin_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    admin_user = update.effective_user
    if query is None or admin_user is None:
        return

    await query.answer()
    data = query.data or ""
    if ":" not in data:
        return
    action, request_id = data.split(":", 1)

    request = _get_pending_request(context, request_id)
    if request is None:
        await query.answer("–ó–∞–ø—Ä–æ—Å —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.", show_alert=True)
        try:
            await query.edit_message_text("–ó–∞–ø—Ä–æ—Å —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.")
        except Exception:
            pass
        return

    if not _is_admin_user(admin_user):
        await query.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return

    client = request["client"]
    client_label = _format_client_label(client)
    user_chat_id = request["user_chat_id"]
    user_id = request["user_id"]

    if action == "approve":
        try:
            link_user_to_client(
                tg_user_id=user_id,
                client_id=client["id"],
                tg_username=request.get("user_username"),
                tg_full_name=request.get("user_full_name"),
            )
        except Exception:
            LOGGER.exception(
                "Failed to apply approved link for request %s (user %s, client %s)",
                request_id,
                user_id,
                client["id"],
            )
            await query.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–≤—è–∑–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", show_alert=True)
            return

        admin_text = (
            f"‚úÖ –ó–∞–ø—Ä–æ—Å {request_id} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º {_format_user_label(admin_user)}.\n"
            f"–ö–ª–∏–µ–Ω—Ç: {client_label}"
        )
        user_text = (
            f"–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –ø—Ä–∏–≤—è–∑–∫—É –∫ –∫–ª–∏–µ–Ω—Ç—É {client_label}. "
            "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–µ—Ä–≤–∏—Å–æ–º."
        )
    else:
        admin_text = (
            f"‚ùå –ó–∞–ø—Ä–æ—Å {request_id} –æ—Ç–∫–ª–æ–Ω—ë–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º {_format_user_label(admin_user)}.\n"
            f"–ö–ª–∏–µ–Ω—Ç: {client_label}"
        )
        user_text = (
            f"–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –æ—Ç–∫–ª–æ–Ω–∏–ª –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–∏–≤—è–∑–∫—É –∫ –∫–ª–∏–µ–Ω—Ç—É {client_label}. "
            "–°–≤—è–∑—å –æ—Å—Ç–∞–ª–∞—Å—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π."
        )

    _pop_pending_request(context, request_id)

    try:
        await query.edit_message_text(admin_text)
    except Exception:
        LOGGER.debug("Failed to edit admin decision message for request %s", request_id, exc_info=True)

    for message_ref in request.get("admin_messages", []):
        if (
            message_ref.get("chat_id") == query.message.chat_id
            and message_ref.get("message_id") == query.message.message_id
        ):
            continue
        try:
            await context.bot.edit_message_text(
                admin_text,
                chat_id=message_ref["chat_id"],
                message_id=message_ref["message_id"],
            )
        except Exception:
            LOGGER.debug("Failed to update admin message for request %s", request_id, exc_info=True)

    try:
        await context.bot.send_message(user_chat_id, user_text)
    except Exception:
        LOGGER.exception(
            "Failed to notify user %s about decision %s for request %s",
            user_id,
            action,
            request_id,
        )


def create_application(token: str, greeting: str = DEFAULT_GREETING) -> Application:
    """Create a Telegram application with surname-based client linking."""
    if not token:
        raise ValueError("Telegram bot token must be provided")

    application = Application.builder().token(token).build()
    application.bot_data[_GREETING_KEY] = greeting or DEFAULT_GREETING

    conversation = ConversationHandler(
        entry_points=[CommandHandler("start", _start_handler)],
        states={
            ASK_LAST_NAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_last_name),
            ],
            CONFIRM_LINK: [
                CallbackQueryHandler(_handle_link_selection, pattern=r"^link:\d+$"),
                CallbackQueryHandler(_handle_new_client_request, pattern=r"^new_client$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_last_name),
            ],
            FORM_FIRST_NAME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_first_name),
            ],
            FORM_LAST_NAME: [
                CallbackQueryHandler(_keep_last_name, pattern=r"^form:keep:last_name$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_last_name),
            ],
            FORM_WEIGHT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_weight),
            ],
            FORM_HEIGHT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_height),
            ],
            FORM_GENDER: [
                CallbackQueryHandler(_handle_gender_selection, pattern=r"^form:set:gender:(male|female)$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _prompt_gender_buttons),
            ],
            FORM_FTP: [
                CallbackQueryHandler(_skip_ftp, pattern=r"^form:skip:ftp$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_ftp),
            ],
            FORM_PEDALS: [
                CallbackQueryHandler(_handle_pedals_selection, pattern=r"^form:set:pedals:[^:]+$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_pedals),
            ],
            FORM_GOAL: [
                CallbackQueryHandler(_skip_goal, pattern=r"^form:skip:goal$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, _handle_form_goal),
            ],
        },
        fallbacks=[CommandHandler("cancel", _cancel_handler)],
        name="client_authorization",
        persistent=False,
    )

    application.add_handler(conversation)
    application.add_handler(CommandHandler("help", _help_handler))
    application.add_handler(CallbackQueryHandler(_handle_admin_decision, pattern=r"^(approve|reject):"))
    application.add_handler(MessageHandler(filters.COMMAND, _unknown_command_handler))

    return application


__all__ = ["create_application", "DEFAULT_GREETING"]
